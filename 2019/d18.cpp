#include <map>
#include <set>

#include "common.h"

// clang-format off
const VS input136 =
    {
        "#################",
        "#i.G..c...e..H.p#",
        "########.########",
        "#j.A..b...f..D.o#",
        "########@########",
        "#k.E..a...g..B.n#",
        "########.########",
        "#l.F..d...h..C.m#",
        "#################"
    };
const vector<string> main_input =
    {"#################################################################################",
     "#..f....#...........#.....#.........#m..#.........#.#.......#...............#...#",
     "#.#.###.#########.#.#.###.#.#.#####.#.#.#Q#.#####.#.#.###.###.#V#####.#####.#.#C#",
     "#.#...#...........#t#.#.#...#.#...#.#.#.#.#.#.......#.#.#.....#.....#.#...#...#.#",
     "#####.###############.#.#####.#.#.###.#.#.#.#########.#.###########.###.#.#####.#",
     "#.....#...............#...#.#...#...#.#.#.#.........#.#...........#.....#.#...#e#",
     "#.###.#.###############.#.#.#######.#I#.#.#########.#.###########.#####.#.#.#.#.#",
     "#...#.#...#.....#.......#.....#.G.#.#.#.#.#.......#.#.....#.......#...#.#...#.#.#",
     "###.#.###.#.#.#.###.###########.#.#.#.#.#.#####.#.#.#####.#.#.#####.#.#######.#.#",
     "#...#.#...#.#.#...#.#...#.....#b#.#...#.#.......#.#.........#.#.....#.#...#...#.#",
     "#.#####.###.#.###.#.#.#.#.###.#.#.#####.#########.#############.#####.#.#.#.###.#",
     "#.......#.#.#...#.Z.#.#.B.#.....#.....#.#.......#.....#.........#.#.....#...#...#",
     "#.#######.#.###.#####.#.#############.#M#.#.#########.#.#########.#.#############",
     "#.#.......#...#.#.....#u#...K.......#.#.#.#...........#...#.........#...........#",
     "#.###.###.#.###.#.#####.#.#####.###.#.#.#.#############.#.#.#########.#########.#",
     "#...#...#...#...#.U.#...#.#..j#...#.#g..#.......#...R.#.#.#.....#.....#.......#.#",
     "###.#######.#.#####.#####.#.#.###.#.#############.###.#.#.#######.#########.###.#",
     "#.#.......#.#.....#..k....#.#.#d..#.#...#.........#...#.#.........#.#.......#...#",
     "#.#######.#.#####.#####.###.#.#####.#.#.#.#########.###.#########.#.#.#.#####.#.#",
     "#.....#...#.#.....#.H.#.#...#.S...#.D.#.#...#.....#.#...#.#.....#.#...#..a#...#.#",
     "#.#.#.#.#####.#####.#.#.#.#######.#####.###.#.###.#.###.#.#.###.#.#.#####.#.###.#",
     "#.#.#.#...#...#...#.#.#.#.#.....#.....#s#...#...#.#...#...#...#.#.#...#...#.#...#",
     "###.#.###.#.###.#.#.#####J###.#######.#.#.#######.###.###.#####.#.#.###.#.#.#.###",
     "#...#.#...#.#...#.#.#.....#...#.....#...#.#...#.....#.#...#...#.#.#.#...#.#.#...#",
     "#.#####.###.#.###.#.###.###.###.#.#.#####.#.#.#.###.#.###.###.#.#.###.###.#.###.#",
     "#.....#...#...#...#....h#...#...#.#.#...#...#.#.#.#.#...#.....#.#.....#...#.#.#.#",
     "#.###.###.#.###.###########.#.###.#.###.#####.#.#.#.###.#######.#######.###.#.#.#",
     "#.#.#.....#.#...#.....#...#...#.#.#.....#...#...#...#.#...#.....#.......#.#.#..p#",
     "#.#.#########.###.#.#.#.#.###.#.#.#####.#.#######.###.###.#.###########.#.#.###.#",
     "#.#.#.......#.....#.#...#...#...#.#...#.#.......#.#.#...#.#.......#...#.#.#...#.#",
     "#.#.#.###.#.#.#####.#######.#####.###.#.#.#####.#.#.#.#.#.#######.#.#.#.#.###.#.#",
     "#.#...#...#.#.....#.......#.....#...#...#.....#.#.#...#.#...#...#...#.#.#.#...#.#",
     "#.#####.###.#####.#######.#####.###.#.###.#####.#.#####.#.###.#.#####.#.#.#.###.#",
     "#...N.#.#.#.#.....#.......#...#.....#.#.#.#...#.#.......#.....#.......#...#...#.#",
     "#####.#.#.#.#.#####.#######.#########.#.###.#.#.#######.#####################.#.#",
     "#...#...#...#.....#.......#.#...#.....#.#...#.....#...X.#.....Y.#...#...W.....#.#",
     "###.#####.#######.#######.#.#.#.#.#####.#.#########.#########.#.###.#.#.#######.#",
     "#...#.....#...#.....#...#.#.#.#...#.....#.#.....#...#...#...#.#...#...#.#.#.....#",
     "#.###.#####.#.#######.#.#.#.#.#######.#.#.#.###.#.###.#.#.#.#.###.#####.#.#.#####",
     "#.........A.#.........#...#..x........#.......#.......#...#...#.........#.......#",
     "#######################################.@.#######################################",
     "#.O.......#.............#.......#.....................#...........#...#...#.#...#",
     "###.#####.#######.#####.###.#.#.#.#####.#.#.#########.#######.###.#.#.#.#.#.#.#.#",
     "#...#...#.......#.#..y....#.#.#.#.#...#.#.#.#.....#.........#...#.#.#...#.#.#.#.#",
     "#.#####.#######.#.#.#####.###.#.#.#.#.#.###.#.###.#########.###.#.#.#####.#.#.#.#",
     "#.#...#.......#.#.#.#...#.....#...#.#.#.#...#...#...#.....#.....#.#...#.#.#...#.#",
     "#.#.#.#####.###.#.###.#.#############.#.#.#####.###.#.###.#######.###.#.#.#####.#",
     "#..r#.#...#.....#.#.L.#.#...#...#.....#.#.........#.#.#...#.....#.....#.#.#..n..#",
     "#####.#.#.###.###.#.###.#.#.#.#.###.###.#.#######.#.#.#.###.###.#######.#.#.#####",
     "#...#...#...#..w..#.#.#.#.#.#.#...#...#.#...#...#.#...#...#.#...#.....#...#.....#",
     "#.#.#######.#######.#.#.#.#.#.###.###.#.###.#.#.#######.#.#.#.#####.###.###.###.#",
     "#.#...#...#.....#...#.#...#.....#...#.#.#.#.#.#.......#.#...#.#...#.#...#...#...#",
     "###.#.#.#######.#.###.#########.###.#.#.#.#.#.#######.#.#####.#.#.#.#.#####.#.###",
     "#...#...#...#.P.#.#...#.#.....#.#...#.#.#...#.#.#...#.#...#o#...#.#...#...#.#...#",
     "#.#####.#.#.#.###.#.#.#.#.###.###.###.#.#.###.#.#.#.#.###.#.#####.#.###.#.#.###.#",
     "#.....#.#.#.#.....#.#...#...#.....#...#.#...#.#...#.#.#.....#.....#.#...#.#...#.#",
     "#.###.#.#.#.#######.#######.#########.#.#####.#.###.#.#.#####.#####.#.###.#.###.#",
     "#.#.#.#.#.#...#.#.....#.....#...#...#.#.#.....#.#.#.#.#.#.....#...#.#...#.#.#...#",
     "#.#.#.###.#.#.#.#.###.#.#####.#.#.#.#.#.#.#####.#.#.#.###.#####.###.###.#.###.###",
     "#.#.#.E...#.#.#...#...#...#...#...#...#.#.....#.#.#.......#.........#..l#...#...#",
     "#.#.#######.#.#####.###.#.#.#.#####.###.#####.#.#.#########.###.#####.#####.###.#",
     "#.#.......#.#.....#.#.#.#.#.#.#...#.#...#.....#.#.#.....#...#.#.#...#.#...#.....#",
     "#.#.#####.#.#####.#.#.#.#.###.#.#.###.###.#####.#.#.###.#####.#.#.#.#.###.#####.#",
     "#.#.#.....#.#.......#.#.#.#...#.#.#...#.#.#.....#.#.#.#.....#.#...#...#...#.....#",
     "#.#.#.#####.#.#######.#.#.#.###.#.#.###.#.#.#####.#.#.#####.#.#########.###.#####",
     "#.#.#...#...#.#..q#...#.#.#.....#.#.#...#.#.#.....#.#.....#.#.......#...#...#...#",
     "#.#.#.###.###.#.#.#.#####.#.#####.#.###.#.#.#.#.###.###.#.#.#######.#.#.#.#####.#",
     "#.#.#.#...#.#...#.#.......#.....#.#...#.#.#...#.#v..#...#.#...#.....#.#.#.#...#.#",
     "#.#.#.#.###.#.#################.#.###.#.#.###.###.###.#######.#.#####.###.#.#.#.#",
     "#...#.#...#...#.............#...#...#.#.#...#.#...#.........#...#.......#...#...#",
     "#.#####.#.#####.#.###########.#####.#.#.#.#.###.###########.#####.#####.#######.#",
     "#.#...#.#.#.....#.....#.......#.....#.#.#.#...#.#...............#.#...#.......#.#",
     "###.#.###.#.#########.#.#######.#####.#.#.###.#.#.#.#############.###.#####.###.#",
     "#...#...#.#.#.........#.#.....#.....#.#.#.#...#.#.#....c..........#.....#.#.....#",
     "#.#####.#.#.#.#########.#.#.#.#####.#.#.###.###.#.#################.###.#.#######",
     "#.....#...#z#.......#...#.#.#...#.#.#.#.#...#...#.....#.....#...#...#.#.#.......#",
     "#.###.#####.#######.#.###.#.###.#.#.#.#.#.###.#######.###.#.#.#.#.###.#.#T#.###.#",
     "#...#.....#...#...#...#...#...#...#.#.#.#...#.#...#...#...#.#.#...#.#...#.#.#.#.#",
     "###.#####.###.#.#.###########.###.#.#.#.#.#.#.#.###.###.###.#.#####.#F#####.#.#.#",
     "#.......#.......#.............#...#.....#.#...#.........#.....#.............#i..#",
     "#################################################################################"};
const VS input1 = {
    "########################",
    "#f.D.E.e.C.b.A.@.a.B.c.#",
    "######################.#",
    "#d.....................#",
    "########################"
};
const VS input132 =
    {"########################",
     "#...............b.C.D.f#",
     "#.######################",
     "#.....@.a.B.c.d.A.e.F.g#",
     "########################"};
// clang-format on

struct Vault
{
    VS rows;
    int H, W;
    Vault(VS area) : rows(area)
    {
        assert(!rows.empty());
        H = ~rows;
        W = ~(rows[0]);
        for (auto& r : rows) {
            assert(~r == W);
        }
    }
    char at(AI2 rc) const
    {
        assert(0 <= rc[0] && rc[0] < H);
        assert(0 <= rc[1] && rc[1] < W);
        return rows[rc[0]][rc[1]];
    }
    char& at(AI2 rc)
    {
        assert(0 <= rc[0] && rc[0] < H);
        assert(0 <= rc[1] && rc[1] < W);
        return rows[rc[0]][rc[1]];
    }
    AI2 replace1(char fromwhat, char towhat, int min_count, int max_count)
    {
        AI2 rc;
        int count = 0;
        FOR (r, 0, < H) {
            auto& row = rows[r];
            FOR (c, 0, < W) {
                auto& x = row[c];
                if (x == fromwhat) {
                    ++count;
                    x = towhat;
                    rc = AI2{r, c};
                }
            }
        }
        assert(min_count <= count && count <= max_count);
        return rc;
    }
};

struct Target
{
    AI2 loc;
    int dist;
    char what;
};

const AI2 UP{-1, 0};
const AI2 LEFT{0, -1};
const AI2 DOWN{1, 0};
const AI2 RIGHT{0, 1};
const array<AI2, 4> DIRS = {UP, RIGHT, DOWN, LEFT};

struct BitMatrix
{
    int H, W;
    vector<bool> vb;
    BitMatrix(int H, int W) : H(H), W(W), vb(W * H) {}
    bool at(AI2 rc) const
    {
        assert(0 <= rc[0] && rc[0] < H);
        assert(0 <= rc[1] && rc[1] < W);
        return vb[rc[0] * W + rc[1]];
    }
    void set(AI2 rc)
    {
        assert(0 <= rc[0] && rc[0] < H);
        assert(0 <= rc[1] && rc[1] < W);
        vb[rc[0] * W + rc[1]] = true;
    }
};

vector<Target> next_targets(const Vault& v, AI2 loc)
{
    vector<Target> targets;
    BitMatrix visited(v.H, v.W);
    vector<AI2> frontier, next_frontier;
    int step = 0;
    frontier.push_back(loc);
    visited.set(loc);
    while (!frontier.empty()) {
        next_frontier.clear();
        ++step;
        for (auto& l : frontier) {
            for (auto dir : DIRS) {
                auto nb = l + dir;
                if (visited.at(nb)) {
                    continue;
                }
                visited.set(nb);
                auto at = v.at(nb);
                if (at == '#') {
                    continue;
                }
                if (at == '.') {
                    next_frontier.push_back(nb);
                    continue;
                }
                if ('a' <= at && at <= 'z') {
                    targets.push_back(Target{nb, step, at});
                }
            }
        }
        frontier.swap(next_frontier);
    }
    return targets;
}

struct State
{
    Vault v;
    AI2 loc;
    set<char> keys_to_collect;
    int steps_so_far = 0;
    string keys_got;
};

struct State2
{
    Vault v;
    array<AI2, 4> locs;
    bitset<26> ktc;
    int steps_so_far = 0;
    string keys_got;
};

void erase_key(bitset<26>& bs, char c)
{
    auto ix = (int)(c - 'a');
    assert(0 <= ix && ix < bs.size());
    bs.reset(c - 'a');
}

int solve(State st, multimap<int, State>& states)
{
    int best_result = INT_MAX;
    if (st.keys_to_collect.empty()) {
        return st.steps_so_far;
    }
    vector<Target> keys = next_targets(st.v, st.loc);
    assert(!keys.empty());
    for (auto& k : keys) {
        Vault v2(st.v);
        v2.replace1(k.what, '.', 1, 1);
        v2.replace1(toupper(k.what), '.', 0, 1);
        auto ktc2 = st.keys_to_collect;
        ktc2.erase(k.what);
        auto s2 = State{move(v2), k.loc, ktc2, st.steps_so_far + k.dist, st.keys_got + k.what};
        states.emplace(st.steps_so_far + k.dist, move(s2));
    }
    return INT_MAX;
}

int solve2(State2 st, multimap<int, State2>& states)
{
    int best_result = INT_MAX;
    if (st.ktc.none()) {
        return st.steps_so_far;
    }
    bool found_some_keys = false;
    FOR (rx, 0, < 4) {
        vector<Target> keys = next_targets(st.v, st.locs[rx]);
        if (keys.empty()) {
            continue;
        }
        found_some_keys = true;
        for (auto& k : keys) {
            Vault v2(st.v);
            v2.replace1(k.what, '.', 1, 1);
            v2.replace1(toupper(k.what), '.', 0, 1);
            auto st2 =
                State2{move(v2), st.locs, st.ktc, st.steps_so_far + k.dist, st.keys_got + k.what};
            erase_key(st2.ktc, k.what);
            st2.locs[rx] = k.loc;
            states.emplace(st.steps_so_far + k.dist, move(st2));
        }
    }
    assert(found_some_keys);
    return INT_MAX;
}

struct Processed
{
    string keys_got;
    char last_key;
    bool operator<(const Processed& lhs) const
    {
        if (last_key < lhs.last_key) {
            return true;
        }
        if (last_key < lhs.last_key) {
            return false;
        }
        return keys_got < lhs.keys_got;
    }
};

struct Processed2
{
    string keys_got;
    array<AI2, 4> locs;
    bool operator<(const Processed2& lhs) const
    {
        if (locs < lhs.locs) {
            return true;
        }
        if (locs < lhs.locs) {
            return false;
        }
        return keys_got < lhs.keys_got;
    }
};

int solve(State st)
{
    set<Processed> psteps;

    multimap<int, State> states;
    states.emplace(st.steps_so_far, move(st));
    while (!states.empty()) {
        auto it = states.begin();
        auto st = move(it->second);
        states.erase(it);
        auto key = Processed{st.keys_got, st.keys_got.back()};
        sort(BE(key.keys_got));
        if (psteps.count(key) > 0) {
            continue;
        }
        psteps.insert(key);
        printf("st: %d - %s\n", st.steps_so_far, st.keys_got.c_str());
        int result = solve(st, states);
        if (result < INT_MAX) {
            return result;
        }
    }
    assert(false);
    return INT_MAX;
}

int solve2(State2 st)
{
    set<Processed2> psteps;

    multimap<int, State2> states;
    states.emplace(st.steps_so_far, move(st));
    while (!states.empty()) {
        auto it = states.begin();
        auto st = move(it->second);
        states.erase(it);
        auto key = Processed2{st.keys_got, st.keys_got.back()};
        sort(BE(key.keys_got));
        if (psteps.count(key) > 0) {
            continue;
        }
        psteps.insert(key);
        printf("st: %d - %s\n", st.steps_so_far, st.keys_got.c_str());
        int result = solve2(st, states);
        if (result < INT_MAX) {
            return result;
        }
    }
    assert(false);
    return INT_MAX;
}
//clang-format off
const VS in4_8 = {"#######", "#a.#Cd#", "##...##", "##.@.##", "##...##", "#cB#Ab#", "#######"};
const VS in4_32 = {"#############", "#DcBa.#.GhKl#", "#.###   #I###", "#e#d# @ #j#k#",
                   "###C#   ###J#", "#fEbA.#.FgHi#", "#############"};
const VS in4_72 = {"#############", "#g#f.D#..h#l#", "#F###e#E###.#",
                   "#dCba   BcIJ#", "##### @ #####", "#nK.L   G...#",
                   "#M###N#H###.#", "#o#m..#i#jk.#", "#############"};
//clang-format on
int main()
{
    if (0) {
        printf("Part1\n");
        Vault v(main_input);
        auto loc = v.replace1('@', '.', 1, 1);
        set<char> keys_to_collect;
        for (auto& r : v.rows) {
            for (auto c : r) {
                if ('a' <= c && c <= 'z') {
                    keys_to_collect.insert(c);
                }
            }
        }

        auto state = State{v, loc, keys_to_collect};
        int result = solve(state);
        printf("result: %d\n", result);
    }
    {
        printf("Part2\n");
        Vault v(main_input);
        auto loc = v.replace1('@', '.', 1, 1);
        array<AI2, 4> locs;
        int l_ix = 0;
        FOR (r, -1, <= 1) {
            FOR (c, -1, <= 1) {
                auto l = loc + AI2{r, c};
                if (abs(r * c) == 1) {
                    assert(l_ix < locs.size());
                    locs[l_ix++] = l;
                    v.at(l) = '.';
                } else {
                    v.at(l) = '#';
                }
            }
        }

        bitset<26> keys_to_collect;
        for (auto& r : v.rows) {
            for (auto c : r) {
                if ('a' <= c && c <= 'z') {
                    int ix = c - 'a';
                    assert(0 <= ix && ix < keys_to_collect.size());
                    keys_to_collect.set(ix);
                }
            }
        }

        auto state = State2{v, locs, keys_to_collect};
        int result = solve2(state);
        printf("result: %d\n", result);
    }
    return 0;
}
