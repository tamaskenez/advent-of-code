#include "common.h"

using VC = vector<char>;
using VVC = vector<VC>;

class Map
{
    VVC m;

public:
    int W = INT_MIN, H = INT_MIN;
    Map(int w, int h) : m(h, VC(w, '.')), W(w), H(h) {}
    explicit Map(initializer_list<const char*> il)
    {
        for (auto l : il) {
            int w = strlen(l);
            if (W == INT_MIN) {
                W = w;
            } else {
                assert(W == w);
            }
            VC r;
            FOR (i, 0, < w) {
                r.push_back(l[i]);
            }
            m.push_back(move(r));
        }
        H = ~m;
    }
    char operator()(int x, int y) const
    {
        assert(0 <= x && x < W);
        assert(0 <= y && y < H);
        return m[y][x];
    }
    char& operator()(int x, int y)
    {
        assert(0 <= x && x < W);
        assert(0 <= y && y < H);
        return m[y][x];
    }
};

void print(const Map& m)
{
    FOR (y, 0, < m.H) {
        FOR (x, 0, < m.W) {
            auto c = m(x, y);
            printf("%c", c);
        }
        printf("\n");
    }
    printf("\n");
}

// clang-format off
const Map input1({
          ".#..#",
          ".....",
          "#####",
          "....#",
          "...##"
      });
const Map input2({
                     "......#.#.",
                     "#..#.#....",
                     "..#######.",
                     ".#.#.###..",
                     ".#..#.....",
                     "..#....#.#",
                     "#..#....#.",
                     ".##.#..###",
                     "##...#..#.",
                     ".#....####"});
const Map input3({
                     "#.#...#.#.",
                     ".###....#.",
                     ".#....#...",
                     "##.#.#.#.#",
                     "....#.#.#.",
                     ".##..###.#",
                     "..#...##..",
                     "..##....##",
                     "......#...",
                     ".####.###."});
const Map input4({
                     ".#..#..###",
                     "####.###.#",
                     "....###.#.",
                     "..###.##.#",
                     "##.##.#.#.",
                     "....###..#",
                     "..#.#..#.#",
                     "#..#.#.###",
                     ".##...##.#",
                     ".....#.#.."});
const Map input5({
    ".#..##.###...#######",
    "##.############..##.",
    ".#.######.########.#",
    ".###.#######.####.#.",
    "#####.##.#.##.###.##",
    "..#####..#.#########",
    "####################",
    "#.####....###.#.#.##",
    "##.#################",
    "#####.##.###..####..",
    "..######..##.#######",
    "####.##.####...##..#",
    ".#####..#.######.###",
    "##...#.##########...",
    "#.##########.#######",
    ".####.#.###.###.#.##",
    "....##.##.###..#####",
    ".#.#.###########.###",
    "#.#.#.#####.####.###",
    "###.##.####.##.#..##"});
const Map input({
                    "..............#.#...............#....#....",
                    "#.##.......#....#.#..##........#...#......",
                    "..#.....#....#..#.#....#.....#.#.##..#..#.",
                    "...........##...#...##....#.#.#....#.##..#",
                    "....##....#...........#..#....#......#.###",
                    ".#...#......#.#.#.#...#....#.##.##......##",
                    "#.##....#.....#.....#...####........###...",
                    ".####....#.......#...##..#..#......#...#..",
                    "...............#...........#..#.#.#.......",
                    "........#.........##...#..........#..##...",
                    "...#..................#....#....##..#.....",
                    ".............#..#.#.........#........#.##.",
                    "...#.#....................##..##..........",
                    ".....#.#...##..............#...........#..",
                    "......#..###.#........#.....#.##.#......#.",
                    "#......#.#.....#...........##.#.....#..#.#",
                    ".#.............#..#.....##.....###..#..#..",
                    ".#...#.....#.....##.#......##....##....#..",
                    ".........#.#..##............#..#...#......",
                    "..#..##...#.#..#....#..#.#.......#.##.....",
                    "#.......#.#....#.#..##.#...#.......#..###.",
                    ".#..........#...##.#....#...#.#.........#.",
                    "..#.#.......##..#.##..#.......#.###.......",
                    "...#....###...#......#..#.....####........",
                    ".............#.#..........#....#......#...",
                    "#................#..................#.###.",
                    "..###.........##...##..##.................",
                    ".#.........#.#####..#...##....#...##......",
                    "........#.#...#......#.................##.",
                    ".##.....#..##.##.#....#....#......#.#....#",
                    ".....#...........#.............#.....#....",
                    "........#.##.#...#.###.###....#.#......#..",
                    "..#...#.......###..#...#.##.....###.....#.",
                    "....#.....#..#.....#...#......###...###...",
                    "#..##.###...##.....#.....#....#...###..#..",
                    "........######.#...............#...#.#...#",
                    "...#.....####.##.....##...##..............",
                    "###..#......#...............#......#...#..",
                    "#..#...#.#........#.#.#...#..#....#.#.####",
                    "#..#...#..........##.#.....##........#.#..",
                    "........#....#..###..##....#.#.......##..#",
                    ".................##............#.......#.."});
const Map input6({
                     ".#....#####...#..",
                     "##...##.#####..##",
                     "##...#...#.#####.",
                     "..#.....#...###..",
                     "..#.#.....#....##"});
// clang-format on

int sgn(int x)
{
    return x > 0 ? 1 : (x == 0 ? 0 : -1);
}

vector<AI2> visible_from(const Map& m, AI2 loc)
{
    vector<AI2> as;
    FOR (x, 0, < m.W) {
        FOR (y, 0, < m.H) {
            if (AI2{x, y} != loc && m(x, y) == '#') {
                as.push_back(AI2{x, y});
            }
        }
    }
    Map n(m.W, m.H);
    for (auto b : as) {
        assert(loc != b);
        auto dx = b[0] - loc[0];
        auto dy = b[1] - loc[1];
        assert(dx != 0 || dy != 0);
        if (dx == 0 || dy == 0) {
            dx = sgn(dx);
            dy = sgn(dy);
        } else {
            auto k = std::gcd(abs(dx), abs(dy));
            dx /= k;
            dy /= k;
        }
        for (;;) {
            b[0] += dx;
            b[1] += dy;
            if (b[0] < 0 || m.W <= b[0] || b[1] < 0 || m.H <= b[1]) {
                break;
            }
            n(b[0], b[1]) = 'X';
        }
    }
    vector<AI2> r;
    for (auto b : as) {
        assert(loc != b);
        if (n(b[0], b[1]) != 'X') {
            r.push_back(b);
        }
    }
    return r;
}

AI2 operator-(AI2 x, AI2 y)
{
    return AI2{x[0] - y[0], x[1] - y[1]};
}
int solve(const Map& m)
{
    vector<AI2> as;
    FOR (x, 0, < m.W) {
        FOR (y, 0, < m.H) {
            if (m(x, y) == '#') {
                as.push_back(AI2{x, y});
            }
        }
    }
    AI2 best_loc;
    int best_s = INT_MIN;
    // print(m);
    for (auto a : as) {
        Map n(m.W, m.H);
        for (auto b : as) {
            if (a == b) {
                continue;
            }
            auto dx = b[0] - a[0];
            auto dy = b[1] - a[1];
            assert(dx != 0 || dy != 0);
            if (dx == 0 || dy == 0) {
                dx = sgn(dx);
                dy = sgn(dy);
            } else {
                auto k = std::gcd(abs(dx), abs(dy));
                dx /= k;
                dy /= k;
            }
            for (;;) {
                b[0] += dx;
                b[1] += dy;
                if (b[0] < 0 || m.W <= b[0] || b[1] < 0 || m.H <= b[1]) {
                    break;
                }
                n(b[0], b[1]) = 'X';
            }
        }
        // print(n);
        int s = 0;
        for (auto b : as) {
            if (a == b) {
                continue;
            }
            if (n(b[0], b[1]) != 'X') {
                ++s;
            }
        }
        if (s > best_s) {
            best_s = s;
            best_loc = a;
        }
    }
    assert(best_s >= 0);
    printf("best loc: (%d, %d), detected: %d\n", best_loc[0], best_loc[1], best_s);
    Map mm = m;
    int to_go = 200;
    bool done = false;
    AI2 a200;
    for (; !done;) {
        auto vf = visible_from(mm, best_loc);
        if (vf.empty()) {
            break;
        }
        VI xs(~vf);
        iota(BE(xs), 0);
        sort(BE(xs), [&vf, best_loc](int x, int y) {
            auto a = vf[x] - best_loc;
            auto b = vf[y] - best_loc;
            auto pha = a[0] == 0 && a[1] < 0 ? -INFINITY : atan2(-a[0], a[1]);
            auto phb = b[0] == 0 && a[1] < 0 ? -INFINITY : atan2(-b[0], b[1]);
            return pha < phb;
        });
        // Map mmm = mm;
        // print(mmm);
        // int counter = 0;
        for (auto x : xs) {
            auto a = vf[x];
            mm(a[0], a[1]) = '.';
            // mmm(a[0], a[1]) = (char)counter + '0';
            //++counter;
            if (--to_go == 0) {
                done = true;
                a200 = a;
                break;
            }
        }
        // print(mmm);
        int a = 3;
    }
    if (done) {
        printf("a200: (%d, %d)\n", a200[0], a200[1]);
    }
    return best_s;
}

void check(int actual, int expected)
{
    if (actual == expected) {
        printf("%d OK\n", actual);
    } else {
        printf("%d should be %d\n", actual, expected);
    }
}

int main()
{
    const Map m({"#.........", "...#......", "...#..a...", ".####....a", "..#.c.b...", ".....c....",
                 "..efd.c.gb", ".......c..", "....f...c.", "...e..d..c"});
    // solve(m);
    solve(input6);
    check(solve(input1), 7);
    check(solve(input2), 33);
    check(solve(input3), 35);
    check(solve(input4), 41);
    check(solve(input5), 210);
    printf("solution: %d\n", solve(input));
    return 0;
}